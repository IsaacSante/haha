================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-13T00:17:52.192Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
index.html
README.md
scripts.js
styles.css

================================================================
Repository Files
================================================================

================
File: README.md
================
# haha

================
File: index.html
================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Untitled.27</title>
  <meta name="description" content="The HTML5 Herald">
  <meta name="author" content="SitePoint">
  <link rel="shortcut icon" type="image/png" href="download.png">
  <link rel="stylesheet" href="styles.css">
</head>
    <body>
    <div id="instructions" class="instructions">Start typing</div>
    <div id="parent" class="parent"> 
        <p id="content">Hello my name is
         <span id="edit" contenteditable="true" class="single-line"></span>
         </p>
        </div>
  <script src="scripts.js"></script>
</body>
</html>

================
File: scripts.js
================
// Setup before functions
let typingTimeout;
const typingDelay = 2000; 
let userEditableElement;
const followUpMessages = ["and I am from", "and I work in", "and no one gives a flying..."];
const instructionsElement = document.getElementById('instructions');

function updateInstructions(text) {
  instructionsElement.textContent = text;
}

function hideInstructions() {
  instructionsElement.style.opacity = '0';
}

function showInstructions() {
  instructionsElement.style.opacity = '1';
}

function focusLatestEditableSpan() {
    const editableSpans = document.querySelectorAll('[contenteditable="true"]');
    const latestSpan = editableSpans[editableSpans.length - 1];
    if (latestSpan) {
        latestSpan.focus();
    }
}

function setupEventListeners() {
    userEditableElement = document.getElementById('edit');
    userEditableElement.addEventListener('keyup', () => {
        clearTimeout(typingTimeout);
        if (userEditableElement.innerText) {
            updateInstructions("Loading response from haha ai");
            typingTimeout = setTimeout(() => addNextMessage(0), typingDelay);
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    setupEventListeners();
    focusLatestEditableSpan();
    showInstructions();
});

function addNextMessage(index) {
    const contentElement = document.getElementById("content");
    contentElement.innerHTML += followUpMessages[index] + "&nbsp;";

    if (index < followUpMessages.length - 1) {
        // Create editable span for all but the last message
        const newEditableSpan = document.createElement('span');
        newEditableSpan.contentEditable = "true";
        newEditableSpan.setAttribute("contenteditable", "true");
        newEditableSpan.setAttribute("id", `edit${index + 1}`);
        contentElement.appendChild(newEditableSpan);
        
        newEditableSpan.addEventListener('keyup', () => {
            clearTimeout(typingTimeout);
            if (newEditableSpan.innerText) {
                updateInstructions("Loading response from haha ai");
                typingTimeout = setTimeout(() => addNextMessage(index + 1), typingDelay);
            }
        });
        focusLatestEditableSpan();
        updateInstructions("Start typing");
    } else {
        // This is the last message, add the final text after a delay
        const finalDelay = 1000;
        setTimeout(() => {
            hideInstructions();
            setTimeout(addFinalText, 300); // Hide instructions before showing final text
        }, finalDelay);
    }
}

// Final text displayed
function addFinalText() {
    const finalText = document.createElement('h1');
    finalText.textContent = "Jk remember you are valuable and be kind to yourself :-)";
    finalText.className = 'final-text';
    document.body.appendChild(finalText);
    createTextRain();
}

function createTextRain() {
    const numberOfDrops = 100;
    let dropsFinished = 0;
    const haVariations = ["ha", "haha"];

    for (let i = 0; i < numberOfDrops; i++) {
        setTimeout(() => {
            const drop = document.createElement('div');
            drop.className = 'text-drop';
            drop.style.left = `${Math.random() * 100}vw`;
            drop.style.animationDuration = `${Math.random() * 2 + 3}s`;
            
            drop.textContent = haVariations[Math.floor(Math.random() * haVariations.length)];
            document.body.appendChild(drop);

            drop.addEventListener('animationend', () => {
                document.body.removeChild(drop);
                dropsFinished++;
                if (dropsFinished === numberOfDrops) {
                    setTimeout(resetHaha, 1000);
                }
            });
        }, i * 50); 
    }
}

function resetHaha() {
    const contentElement = document.getElementById("content");
    contentElement.innerHTML = 'Hello my name is <span id="edit" contenteditable="true" class="single-line"></span>';

    const additionalSpans = document.querySelectorAll('[id^="edit"]:not(#edit)');
    additionalSpans.forEach(span => span.remove());

    const finalText = document.querySelector('.final-text');
    if (finalText) {
        finalText.remove();
    }

    const textDrops = document.querySelectorAll('.text-drop');
    textDrops.forEach(drop => drop.remove());

    clearTimeout(typingTimeout);
    showInstructions();
    updateInstructions("Start typing");
    setupEventListeners();  
    focusLatestEditableSpan();
}

================
File: styles.css
================
body {
  background-color: white;
  overflow: hidden; 
}

.instructions {
  position: fixed;
  top: 10vh;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.5em;
  color: #333;
  padding: 10px 20px;
  z-index: 30;
  transition: opacity 0.3s ease;
}


p {
  margin: 0;
  padding: 0;
  font-size: 2.3em;
  line-height: 1.5; 
  word-wrap: break-word;
  overflow-wrap: break-word;
}

[contenteditable]:focus {
  outline: 0px solid transparent;
}

[contenteditable="true"].single-line {
  white-space: normal;
  overflow: visible;
}

[contenteditable="true"].single-line br {
  display: inline;
}

[contenteditable="true"].single-line * {
  display: inline;
  white-space: normal;
}

[contenteditable="true"]:empty::after {
  content: '';
  display: inline-block;
  width: 1px;
  height: 1.2em;
  background-color: #000;
  animation: blink 0.7s infinite;
  vertical-align: text-bottom;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

.parent {
  padding: 1%;
  border-style: solid;
  border-color: black;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40vh;
  min-height: 40vh;
  max-height: 80vh;
  text-align: left;
  z-index: 10;
  background-color: white;
  overflow-y: auto;
  overflow-x: hidden;
  display: block;
}

#edit, span[contenteditable="true"] {
  background-color: #E2DCCD;
  padding: 0.1em 0.2em; 
  margin: 0 0.1em; 
  display: inline-block;
  max-width: 100%;
  word-wrap: break-word;
  overflow-wrap: break-word;
  line-height: 1.5; 
  cursor: text;
}

.final-text {
  position: fixed;
  bottom: 10vh;
  left: 0;
  width: 100%;
  text-align: center;
  font-size: 1.5em;
  line-height: 1.4;
  padding: 0 20px;
  box-sizing: border-box;
  z-index: 20;
  background-color: rgba(255, 255, 255, 0.8);
  
  background-image: linear-gradient(
    to right,
    #ff0000,
    #ff0000,
    #ff7f00,
    #ffff00,
    #00ff00,
    #0000ff,
    #0000ff,
    #8b00ff,
    #ff0000,
    #ff0000
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: enhanced-rainbow-animation 6s linear infinite;
}

@keyframes enhanced-rainbow-animation {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}
.text-drop {
  position: fixed;
  top: -20px;
  color: rgba(0, 0, 0, 0.5);
  font-size: 1.5em;
  z-index: 5;
  animation: rainFall linear forwards;
}

@keyframes rainFall {
  to {
    transform: translateY(calc(100vh + 20px));
  }
}
